
> merge-nb@0.0.2 test:vscode
> npm run compile && npm run compile-tests && node out/tests/runIntegrationTest.js


> merge-nb@0.0.2 compile
> npm run check-types && npm run lint && node esbuild.js


> merge-nb@0.0.2 check-types
> tsc --noEmit


> merge-nb@0.0.2 lint
> eslint src

[watch] build started
[watch] build started
[watch] build finished
[watch] build finished
[katex] Copied KaTeX dist bundle

> merge-nb@0.0.2 compile-tests
> tsc -p . --outDir out

Created test workspace at: /tmp/mergeNB-integration-w3Uthg
- Resolving version...
‚úî Validated version: 1.108.2
‚úî Found existing install in /home/avni/source/repos/MergeNB/.vscode-test/vscode-linux-x64-1.108.2
[90m[main 2026-02-04T09:52:13.559Z][0m update#setState disabled
[90m[main 2026-02-04T09:52:13.561Z][0m update#ctor - updates are disabled by the environment
[170691:0204/035213.571230:ERROR:media/gpu/vaapi/vaapi_wrapper.cc:1631] vaInitialize failed: unknown libva error
[170656:0204/035214.539187:ERROR:base/nix/mime_util_xdg.cc:139] Invalid mime.cache file does not contain null prior to ALIAS_LIST_OFFSET=44
Started local extension host with pid 170837.
Loading development extension at /home/avni/source/repos/MergeNB
MCP Registry configured: https://api.mcp.github.com
Settings Sync: Account status changed from uninitialized to unavailable
MergeNB extension is now active
Starting MergeNB VS Code Integration Test...
Test workspace: /tmp/mergeNB-integration-w3Uthg
Executing merge-nb.findConflicts command...
Waiting for web server to start (checking port file)...
[MergeNB] detectSemanticConflicts for: /tmp/mergeNB-integration-w3Uthg/conflict.ipynb
[MergeNB] base length: 51829
[MergeNB] current length: 1992378
[MergeNB] incoming length: 51463
[MergeNB] base === current: false
[MergeNB] base === incoming: false
[MergeNB] current === incoming: false
[MergeNB] LEGO CELL PARSED:
[MergeNB] - base has "Key insight": true
[MergeNB] - current has "Key insight": true
[MergeNB] - incoming has "Key insight": true
[MergeNB Web] Server started at http://localhost:39999
[MergeNB Web] Opening browser to: http://localhost:39999/?session=session-1770198739464-x20lujr2e
Found server port from file: 39999
Server verified healthy on port 39999
Waiting for session to be registered...
[MergeNB Web] WebSocket connected for session: session-1770198739464-x20lujr2e
[MergeNB] [WebConflictPanel] Opened conflict resolver in browser, session: session-1770198739464-x20lujr2e
[MergeNB Web] Received message from session session-1770198739464-x20lujr2e: ready
Found session: session-1770198739464-x20lujr2e
Launching Playwright browser...
Navigating to: http://127.0.0.1:39999/?session=session-1770198739464-x20lujr2e
[Browser] %cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools font-weight:bold
Waiting for conflict data to load...
[MergeNB Web] WebSocket connected for session: session-1770198739464-x20lujr2e
[MergeNB Web] Received message from session session-1770198739464-x20lujr2e: ready
[Browser] [MergeNB] WebSocket connected
[Browser] [MergeNB] Received: {type: connected, sessionId: session-1770198739464-x20lujr2e}
[Browser] [MergeNB] Received: {type: conflict-data, data: Object}
[Browser] LaTeX-incompatible input and strict mode is set to 'warn': In LaTeX, \\ or \newline does nothing in display mode [newLineInDisplayMode]
[Browser] LaTeX-incompatible input and strict mode is set to 'warn': In LaTeX, \\ or \newline does nothing in display mode [newLineInDisplayMode]
[Browser] Failed to load resource: the server responded with a status of 404 (Not Found)
[Browser] Failed to load resource: the server responded with a status of 404 (Not Found)
[Browser] Failed to load resource: the server responded with a status of 404 (Not Found)
[Browser] Failed to load resource: the server responded with a status of 404 (Not Found)
[Browser] Failed to load resource: the server responded with a status of 404 (Not Found)
[Browser] Failed to load resource: the server responded with a status of 404 (Not Found)
[Browser] Failed to load resource: the server responded with a status of 404 (Not Found)
[Browser] Failed to load resource: net::ERR_BLOCKED_BY_RESPONSE.NotSameOrigin

=== CAPTURING ROW DATA ===

Found 71 total merge rows
Row 15: CONFLICT (conflict-row-0)
Row 16: CONFLICT (conflict-row-1)
Row 19: CONFLICT (conflict-row-2)
Row 20: CONFLICT (conflict-row-3)
Row 48: CONFLICT (conflict-row-4)
Row 49: CONFLICT (conflict-row-5)
Row 50: CONFLICT (conflict-row-6)
Row 51: CONFLICT (conflict-row-7)
Row 52: CONFLICT (conflict-row-8)
Row 53: CONFLICT (conflict-row-9)
Row 55: CONFLICT (conflict-row-10)
Row 57: CONFLICT (conflict-row-11)
Row 58: CONFLICT (conflict-row-12)
Row 60: CONFLICT (conflict-row-13)
Row 61: CONFLICT (conflict-row-14)
Row 62: CONFLICT (conflict-row-15)
Row 63: CONFLICT (conflict-row-16)
Row 66: CONFLICT (conflict-row-17)
Row 67: CONFLICT (conflict-row-18)
Row 69: CONFLICT (conflict-row-19)

=== SUMMARY ===

Total rows: 71
Conflict rows: 20
Identical rows: 51

=== RAW CAPTURED DATA (JSON) ===

[
  {
    "rowIndex": 0,
    "isConflict": false,
    "testId": "row-0",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "2. Method 1: Spectral Hashing\n2.1 The Problem: Open Modification Searching is Slow\nOpen Modification Searching (OMS) is used to identify post-translationally modified peptides in mass spec data.\n\n\nPost Translational Modifications (PTMs): Chemical ‚Äúadd-ons‚Äù to proteins after being synthesized.\n\nEg. an oxygen atom ‚Äústicking to‚Äù a peptide is called oxidation, similarly for, say phosphorylation. This shifts the mass of the peptide by a certain m/z. So if a peak is at m/z = 230 with charge z, adding an oxygen atom (~16 Da) will shift it to approximately 230 + 16/z\n\n\n\nTraditional proteomics search algorithms attempt to match fragmentation spectra by first identifying the mass of the intact peptide. Then, they only consider peptides from the database with a matching mass. This greatly reduces the search space from hundreds of thousands of peptides down to dozens.\n\n\nIn OMS, every peptide in the database is considered as a potential match to every MS2 fragmentation spectrum. When a peptide-spectrum match is found, you can look for mass shifts to identify PTMs. ‚ÄúAll possible modifications are implicitly considered.‚Äù\n\n\nThe catch: OMS is computationally expensive because we compare every spectrum against every peptide in the database.\n\n\n\n2.2 The Approach: Clustering\nInstead of comparing every spectrum to every peptide, we can use clustering to group similar spectra together. If we know the identity of some spectra ahead of time (e.g., those identified using a traditional search), then we have a good idea of the identity of every spectrum in that cluster.\nThis approach was used by ANN-SoLo, which we‚Äôll follow throughout this notebook:\n",
      "cellType": "markdown"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 1,
    "isConflict": false,
    "testId": "row-1",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "2.3 The Lego Analogy\nTo understand clustering, imagine you‚Äôre building a large Lego set with ~2,000 pieces.\nThe naive approach:\n\nDump all pieces out at once\nFor each instruction, search through the entire pile to find the piece you need\n\nThe clustering approach:\n\nDump all pieces out at once\nFirst, sort pieces into piles by shape (2x4 studs, 1x2 studs, etc.)\nFor each instruction, go directly to the relevant pile\n\nIf you grab any piece from a pile, it‚Äôs representative of all pieces in that pile. This lets you quickly skip irrelevant piles. Now imagine 2,000,000 pieces ‚Äî the efficiency gain becomes enormous.\n\nKey insight: There‚Äôs a balance between ‚Äútoo specific‚Äù (too many small piles) and ‚Äútoo generic‚Äù (piles with mixed pieces). The same applies to clustering spectra.\n\n\nFor spectra, clustering works the same way:\n\n\n\nLego Approach\nSpectra Approach\n\n\n\n\nGroup similar pieces into piles\nGroup similar spectra into clusters\n\n\nIdentify one piece per pile\nIdentify one spectrum per cluster (using traditional search)\n\n\nAll pieces in pile share that identity\nAll spectra in cluster share that peptide identity\n\n\n\nThis transforms millions of comparisons into just thousands!\n\nHow do we group spectra together?\n\nConvert each spectrum into a vector (a list of numbers capturing the spectrum‚Äôs characteristics)\nMeasure distances between vectors ‚Äî similar spectra end up close together in multi-dimensional space\nGroup nearby vectors into clusters ‚Äî this is the actual ‚Äúclustering‚Äù\nMatch by association ‚Äî unknown spectra inherit identities from known spectra in their cluster\n\nA visual example in 2D\nThe graphics below walk through clustering spectra in 2 dimensions. In reality, we‚Äôll work with hundreds of dimensions, but the core idea is exactly the same.\nKey insight: distance = similarity. When two spectra map to nearby points, they‚Äôre similar. When they‚Äôre far apart, they‚Äôre different.\n\n\n\n",
      "cellType": "markdown"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 2,
    "isConflict": false,
    "testId": "row-2",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "2.4 From Peaks to Vectors: The Dimensionality Problem\nUnderstanding ‚Äúhigh-dimensional‚Äù data\nWhen you look at a spectrum, you see 2 dimensions: m/z on the x-axis and intensity on the y-axis. But for clustering, we need to represent each spectrum as a single point in space.\nImagine each possible m/z value as its own ‚Äúdimension.‚Äù We create a vector mapping m/z bins to intensities:\n\nBin 1: m/z 100-101 (intensity = 0)\nBin 2: m/z 101-102 (intensity = 500)\nBin 3: m/z 102-103 (intensity = 0)\nBin 4: m/z 103-104 (intensity = 1200)\n‚Ä¶ and so on\n\nThis gives us a vector like [0, 500, 0, 1200, ...] where each position corresponds to one m/z bin. With 880 bins, that‚Äôs an 880-dimensional vector!\nThe challenge\nFor fine precision (bins of 0.01 Da), we need 88,000 dimensions. That‚Äôs computationally expensive for clustering algorithms.\n\nLego analogy: Imagine if instead of sorting by ‚Äú2x4 stud‚Äù vs ‚Äú1x2 stud‚Äù, you sorted by exact color shade, manufacturing date, and serial number. You‚Äôd have thousands of tiny piles ‚Äî too specific to be useful!\n\n",
      "cellType": "markdown"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 3,
    "isConflict": false,
    "testId": "row-3",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "2.5 Spectral Embedding: The Two-Step Pipeline\nSpectral embedding compresses our high-dimensional representation (88,000 dimensions) down to a manageable size (800 dimensions) while preserving the important relationships between spectra.\nThe ANN-SoLo paper breaks this into two steps:\n\n\n\n\nStep\nWhat it does\nLego analogy\n\n\n\n\nSpectrum Binning\nConvert spectrum to sparse vector using fine m/z bins\nCategorize pieces by precise measurements\n\n\nFeature Hashing\nCompress sparse vector to fixed-size vector\nMerge similar enough categories into manageable piles\n\n\n\nWe‚Äôll implement each step in detail below.\n",
      "cellType": "markdown"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 4,
    "isConflict": false,
    "testId": "row-4",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "\n# @title Run this cell to import all necessary packages\n\n%pip install matplotlib\n\nimport spectrum_utils.plot as sup\nimport spectrum_utils.spectrum as sus\nimport pyteomics\nfrom pyteomics import mzml, auxiliary\nimport plotly.io as pio\nimport plotly.tools as tls\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport numpy as np\nfrom rapidhash import rapidhash\nfrom IPython.display import display, Latex\nfrom util import *\nfrom matplotlib.lines import Line2D\n",
      "cellType": "code"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 5,
    "isConflict": false,
    "testId": "row-5",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "Throughout our examples, we‚Äôll use one sample mzml file:\n",
      "cellType": "markdown"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 6,
    "isConflict": false,
    "testId": "row-6",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "# @title Run this to define our mzml paths\n \nfull_calibrated_mzml_path = '04-17-23_CA_Tryp_HCD_10min_CLEAN-calib.mzML'\n\"\"\"\nFull, sample mzML file\n\"\"\"",
      "cellType": "code"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 7,
    "isConflict": false,
    "testId": "row-7",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "The get_MS2_object function takes in a path and a scan number. This scan number tells it to retrieve the MS2 corresponding to the scan number from that mzML file.\n",
      "cellType": "markdown"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 8,
    "isConflict": false,
    "testId": "row-8",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "ms2_spectrum_5672 = get_MS2_object(full_calibrated_mzml_path, 5672)\nplot_MS2(ms2_spectrum=ms2_spectrum_5672)",
      "cellType": "code"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 9,
    "isConflict": false,
    "testId": "row-9",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "Grab the intensity and mz arrays from the object above:\n",
      "cellType": "markdown"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 10,
    "isConflict": false,
    "testId": "row-10",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "# grab mz values from that ms2 object as a list\nspectrum_mz = ms2_spectrum_5672.mz\n# grab intensity from that ms2 object as a list\nspectrum_int = ms2_spectrum_5672.intensity",
      "cellType": "code"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 11,
    "isConflict": false,
    "testId": "row-11",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "Here are the numerical values AKA how we represent our list of peaks:\nspectrum_mz =\n[129.10229301 147.11281745 185.16487986 186.16810345 213.15977385\n 229.11842622 260.19708681 298.14008063 300.15565245 328.18728919\n 347.22931143 348.23238243 462.25621643 463.25947053 484.20451703\n 575.34033321 646.37762047 647.38017268 743.39337543 761.40367098\n 762.4065894  763.40944677 874.48766569 875.49046204]\n\n\nspectrum_int =\n[2174.818  3145.84   9230.925  2883.7764 4380.564  2282.9873 3063.1228\n 2072.459  3142.8696 2672.6929 5380.33   2240.3975 6059.931  2831.662\n 2237.5989 3632.9626 4356.975  2494.9565 2366.8223 8133.1064 5098.785\n 2226.6924 4098.929  2766.6738]\n\n",
      "cellType": "markdown"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 12,
    "isConflict": false,
    "testId": "row-12",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "# Intensity and mz values are parallel arrays, which you can either count the lengths of \n# or just assert and see it doesn't throw an error\nassert(len(spectrum_int) == len(spectrum_mz))",
      "cellType": "code"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 13,
    "isConflict": false,
    "testId": "row-13",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "Choosing the right bin width\nBefore we start binning, we need to choose our bin size. Using bins of 1 Da (rounding to nearest integer):\n\nIn the 129th idx: 2174.818\nIn the 147th idx: 3145.84\nIn the 185th idx: 9230.925\n‚Ä¶ and so on for an array of length ~880\n\n\nWhy do we want at most 1 peak per bin?\nWhen each bin contains at most one peak, we preserve maximum information. If multiple peaks fall into the same bin, one intensity overwrites another ‚Äî we lose data.\n\nLego analogy: If you dump all red 2x4s AND all blue 2x4s into the same pile, you can no longer distinguish them. For clustering spectra, we want to preserve as much detail as possible.\n\nIf we had 200 unique m/z values ranging from 100‚Äì300 and rounded to the nearest integer, we‚Äôd quickly run into overlaps. Every value between 129.0 ‚â§ m/z < 130.0 would collapse into index 129.\nFiner-grained buckets reduce collisions:\n\n\n\nPrecision\nArray Length (max m/z = 880)\n\n\n\n\n1 Da\n880 buckets\n\n\n0.1 Da\n8,800 buckets\n\n\n0.01 Da\n88,000 buckets\n\n\n\n",
      "cellType": "markdown"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 14,
    "isConflict": false,
    "testId": "row-14",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "\nAccurate vs. Naive approach\nHere‚Äôs the Naive approach with making such a vector. Here, we round down each mz to the nearest integer.\nApproach¬†1:¬†Rounding¬†to¬†nearest¬†integer¬†(1¬†Da¬†bins)Here‚Äôs¬†a¬†list¬†with¬†880¬†zeroes¬†filled¬†in:¬†[,,,‚Ä¶,,]Now,¬†let‚Äôs¬†add¬†a¬†sample¬†of¬†such¬†values¬†at¬†each¬†index:[,‚Ä¶,,‚Ä¶,,‚Ä¶,]\\text{Approach 1: Rounding to nearest integer (1 Da bins)} \\\\[0.5em]\n\\begin{align}\n\\text{Here's a list with 880 zeroes filled in: } &\\quad [\\underset{0}{0}, \\underset{1}{0}, \\underset{2}{0}, \\ldots, \\underset{879}{0}, \\underset{880}{0}] \\\\[0.5em]\n\\text{Now, let's add a sample of such values at each index:} & \\quad [\\underset{0}{0}, \\ldots, \\underset{129}{2174.818}, \\ldots, \\underset{147}{3145.84}, \\ldots, \\underset{880}{0}] \n\\end{align}\nApproach¬†1:¬†Rounding¬†to¬†nearest¬†integer¬†(1¬†Da¬†bins)Here‚Äôs¬†a¬†list¬†with¬†880¬†zeroes¬†filled¬†in:¬†Now,¬†let‚Äôs¬†add¬†a¬†sample¬†of¬†such¬†values¬†at¬†each¬†index:‚Äã[00‚Äã,10‚Äã,20‚Äã,‚Ä¶,8790‚Äã,8800‚Äã][00‚Äã,‚Ä¶,1292174.818‚Äã,‚Ä¶,1473145.84‚Äã,‚Ä¶,8800‚Äã]‚Äã‚Äã\nLike we mentioned though, this takes a lot of accuracy away, and results in quite a few collisions. The approach using finer (to the nearest 0.01 mz) buckets:\nApproach¬†2:¬†Rounding¬†to¬†nearest¬†0.01¬†Da¬†(higher¬†precision)Here‚Äôs¬†a¬†list¬†with¬†88,000¬†zeroes¬†filled¬†in:¬†[,,,‚Ä¶,,]Now,¬†let‚Äôs¬†add¬†a¬†sample¬†of¬†such¬†values¬†at¬†each¬†index:[,‚Ä¶,,‚Ä¶,,‚Ä¶,]\\text{Approach 2: Rounding to nearest 0.01 Da (higher precision)} \\\\[0.5em]\n\\begin{align}\n\n\\text{Here's a list with 88,000 zeroes filled in: } &\\quad [\\underset{0}{0}, \\underset{1}{0}, \\underset{2}{0}, \\ldots, \\underset{87999}{0}, \\underset{88000}{0}] \\\\[0.5em]\n\\text{Now, let's add a sample of such values at each index:} & \\quad [\\underset{0}{0}, \\ldots, \\underset{12910}{2174.818}, \\ldots, \\underset{14711}{3145.84}, \\ldots, \\underset{88000}{0}] \n\\end{align}\nApproach¬†2:¬†Rounding¬†to¬†nearest¬†0.01¬†Da¬†(higher¬†precision)Here‚Äôs¬†a¬†list¬†with¬†88,000¬†zeroes¬†filled¬†in:¬†Now,¬†let‚Äôs¬†add¬†a¬†sample¬†of¬†such¬†values¬†at¬†each¬†index:‚Äã[00‚Äã,10‚Äã,20‚Äã,‚Ä¶,879990‚Äã,880000‚Äã][00‚Äã,‚Ä¶,129102174.818‚Äã,‚Ä¶,147113145.84‚Äã,‚Ä¶,880000‚Äã]‚Äã‚Äã\n",
      "cellType": "markdown"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 15,
    "isConflict": true,
    "testId": "conflict-row-0",
    "base": {
      "exists": true,
      "content": "# @title Run this to see the difference in collisions between widths\nplot_and_show_statistics_for_collisions(full_calibrated_mzml_path)",
      "cellType": "code"
    },
    "current": {
      "exists": true,
      "content": "# @title Run this to see the difference in collisions between widths\nplot_and_show_statistics_for_collisions(full_calibrated_mzml_path)",
      "cellType": "code"
    },
    "incoming": {
      "exists": true,
      "content": "# @title Run this to see the difference in collisions between widths\nplot_and_show_statistics_for_collisions(\"Biogen_ALS_Pilot_1A9_020120-calib-averaged.mzML\")",
      "cellType": "code"
    }
  },
  {
    "rowIndex": 16,
    "isConflict": true,
    "testId": "conflict-row-1",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "incoming": {
      "exists": true,
      "content": "Why ‚Äúcollision rate between spectrum pairs‚Äù?\nAbove, we compare the collision rate when binning with 1 Da vs 0.01 Da. Here‚Äôs why this matters:\nExample: Consider two spectra, A and B, each with only one peak:\n\nSpectrum A has a peak at 90.41 m/z\nSpectrum B has a peak at 90.42 m/z\n\n\n\n\nBin Width\nSpectrum A\nSpectrum B\nResult\n\n\n\n\n1.0 Da\nbin 90\nbin 90\nCollision! Both spectra appear identical\n\n\n0.01 Da\nbin 9041\nbin 9042\nNo collision. Spectra are correctly distinguished\n\n\n\nWith coarse bins, spectra that are actually different can appear similar. This is clearly a false positive. Fine bins preserve the distinction between spectra, which is essential for accurate clustering.\n",
      "cellType": "markdown"
    }
  },
  {
    "rowIndex": 17,
    "isConflict": false,
    "testId": "row-17",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "This clearly demonstrates why we need a smaller bin size. However, we can‚Äôt just make bins arbitrarily small, we must choose a size that is both fine enough to preserve information and realistic for mass spectrometer accuracy.\nThe key consideration is that mass spectrometers have physical precision limitations. While a spectrometer might output a value like m/z=10.023130 m/z =  10.023130 m/z=10.023130, it cannot actually distinguish measurements to that level of precision. In practice, mass spectrometers are reliably accurate to approximately two decimal places (0.01 Da).\n",
      "cellType": "markdown"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 18,
    "isConflict": false,
    "testId": "row-18",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "WIDTH_OF_BIN = 0.01\nLENGTH = int(max(spectrum_mz) // WIDTH_OF_BIN +1) # integer rounding up one.\nprint(f\"We have to fit our m/zs into bins by rounding them to the nearest {WIDTH_OF_BIN}\")\nprint(f\"The length of our (simulated) array will be {LENGTH}\")\n",
      "cellType": "code"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 19,
    "isConflict": true,
    "testId": "conflict-row-2",
    "base": {
      "exists": true,
      "content": "\nStep 1: Spectrum Binning\nNow we implement the first step of the pipeline:\nGoal: Convert the spectrum to a sparse vector using small mass bins (0.01 Da) to tightly capture fragment masses.\n\nLego analogy: This is like measuring each Lego piece precisely ‚Äî recording exact dimensions rather than just ‚Äúsmall‚Äù or ‚Äúlarge.‚Äù\n\n",
      "cellType": "markdown"
    },
    "current": {
      "exists": true,
      "content": "\nStep 1: Spectrum Binning\nNow we implement the first step of the pipeline:\nGoal: Convert the spectrum to a sparse vector using small mass bins (0.01 Da) to tightly capture fragment masses.\n\nLego analogy: This is like measuring each Lego piece precisely ‚Äî recording exact dimensions rather than just ‚Äúsmall‚Äù or ‚Äúlarge.‚Äù\n\n",
      "cellType": "markdown"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 20,
    "isConflict": true,
    "testId": "conflict-row-3",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "incoming": {
      "exists": true,
      "content": "\nStep 1: Spectrum Binning\nNow we implement the first step of the pipeline:\nGoal: Convert the spectrum to a sparse vector using small mass bins (0.01 Da) to tightly capture fragment masses.\n",
      "cellType": "markdown"
    }
  },
  {
    "rowIndex": 21,
    "isConflict": false,
    "testId": "row-21",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "We‚Äôve already chosen our bin width (0.01 Da). Now we‚Äôll define a function to convert m/z values to their binned index.\nFor example: 129.103 m/z ‚Üí index 12910\n",
      "cellType": "markdown"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 22,
    "isConflict": false,
    "testId": "row-22",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "# @title Conversion to sparse vector\n\ndef to_idx(mz):\n    \"\"\"\n    Convert m/z value to a sparse vector index.\n    \"\"\"\n    # concretely: 129.103 // 0.01 == 12910\n    return int(mz // WIDTH_OF_BIN) # rounds down to nearest 0.01.",
      "cellType": "code"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 23,
    "isConflict": false,
    "testId": "row-23",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "Sparse vectors: An optimization\nWith 88,000 possible bins but only ~24 peaks per spectrum, most bins are empty. Storing 88,000 zeros is wasteful.\nA dictionary stores only the non-zero entries:\nInstead of:\n[0, 0, 0, ..., 2174.818, 0, 0, ..., 3145.84, 0, 0, ..., 0]  # 88,000 elements!\n\nWe store:\n{12910: 2174.818, 14711: 3145.84, ...}  # Only 24 entries\n\n\nLego analogy: Instead of labeling 88,000 empty bins, we just keep a list of which bins actually have pieces in them.\n\n",
      "cellType": "markdown"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 24,
    "isConflict": false,
    "testId": "row-24",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "# @title Create the sparse representation: map from m/z indices to intensities\n\nmz_intensity_map = {}\n# Populate the sparse vector with our spectrum data\nfor i, mz in enumerate(spectrum_mz):\n    # Convert each m/z to its corresponding index\n    mz_index = to_idx(mz)\n    # Store the intensity\n    mz_intensity_map[mz_index] = spectrum_int[i]",
      "cellType": "code"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 25,
    "isConflict": false,
    "testId": "row-25",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "What does this look like?\n",
      "cellType": "markdown"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 26,
    "isConflict": false,
    "testId": "row-26",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "# @title Run to visualize the dictionary \nprint(\"The map dictionary looks like:\\n\")\nprint(f\"{'m/z bin':<12} {'Intensity':<12} {'Original m/z'}\")\nprint(\"-\" * 40)\nfor i, (idx, intensity) in enumerate(sorted(mz_intensity_map.items())):\n    print(f\"{idx:<12} {intensity:<12.3f} ({spectrum_mz[i]:.4f})\")\n\nprint(\"\\n\" + \"-\" * 40)\nprint(f\"Total entries: {len(mz_intensity_map)} (instead of ~88,000 zeros!)\")",
      "cellType": "code"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 27,
    "isConflict": false,
    "testId": "row-27",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "Step 1 complete! We have a sparse representation of our spectrum.\n",
      "cellType": "markdown"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 28,
    "isConflict": false,
    "testId": "row-28",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "\nStep 2: Feature Hashing\nNow for the second step of the pipeline:\nGoal: Compress the sparse vector (with indices up to 88,000) into a fixed-size vector of 800 dimensions.\nWhy do we need this?\nOur sparse dictionary is memory-efficient, but we still have problems:\n\nClustering algorithms need fixed-size vectors. You can‚Äôt easily compute distances between dictionaries with different keys.\nThe potential dimensionality is still huge. Even with only 24 entries, those indices span 0‚Äì88,000.\n\nWhat‚Äôs a hash function?\nA hash function converts input data of any size into a fixed-size output:\n\nDeterministic: Same input ‚Üí same output every time\nFixed output size: Always the same length, regardless of input\nFast: Efficiently computable\n\n\nLego analogy: This is like consolidating your 88,000 ultra-precise categories back into 800 practical piles. Pieces that were in nearby categories get merged together.\n\n",
      "cellType": "markdown"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 29,
    "isConflict": false,
    "testId": "row-29",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "How hashing works for our spectra\nA hash function maps any sparse index to a fixed range of buckets:\nhash(12910)‚Üí347(bucket¬†between¬†0¬†and¬†799)\\text{hash}(12910) \\rightarrow 347 \\quad \\text{(bucket between 0 and 799)}\nhash(12910)‚Üí347(bucket¬†between¬†0¬†and¬†799)\nhash(14711)‚Üí102(another¬†bucket)\\text{hash}(14711) \\rightarrow 102 \\quad \\text{(another bucket)}\nhash(14711)‚Üí102(another¬†bucket)\nKey insight: Similar spectra will have similar hash vectors because they share many of the same m/z bins, which hash to the same buckets.\n",
      "cellType": "markdown"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 30,
    "isConflict": false,
    "testId": "row-30",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "Why 800 buckets?\nWe balance two concerns:\n\nLarge enough to minimize collisions (different peaks hashing to the same bucket)\nSmall enough to be computationally efficient for clustering\n\n800 is a good middle ground for typical MS2 spectra.\n",
      "cellType": "markdown"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 31,
    "isConflict": false,
    "testId": "row-31",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "HASH_BUCKETS = 800",
      "cellType": "code"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 32,
    "isConflict": false,
    "testId": "row-32",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "The hash function\nWe‚Äôll use rapidhash, a fast hash function, combined with the modulo operator to map any sparse index to a bucket in the range [0, 799].\n",
      "cellType": "markdown"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 33,
    "isConflict": false,
    "testId": "row-33",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "def hasher(num: int) -> int:\n    \"\"\"\n    Hash function that maps sparse indices to a fixed number of buckets.\n    \n    Input: Large sparse index (e.g., 12910)\n    Output: Small bucket index (0 to 799)\n    \"\"\"\n    # Convert integer to bytes for hashing (rapidhash expects byte input)\n    byte_representation = int(num).to_bytes(8, 'little')\n    \n    # Hash and mod to get bucket index in range [0, hash_buckets-1]\n    return rapidhash(byte_representation) % HASH_BUCKETS",
      "cellType": "code"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 34,
    "isConflict": false,
    "testId": "row-34",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "# @Title Example: see how large indices get mapped to small buckets\nprint(f\"Sparse index 12910 ‚Üí bucket {hasher(12910)}\")\nprint(f\"Sparse index 14711 ‚Üí bucket {hasher(14711)}\")\nprint(f\"Sparse index 87550 ‚Üí bucket {hasher(87550)}\")",
      "cellType": "code"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 35,
    "isConflict": false,
    "testId": "row-35",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "Handling collisions\nWhat happens when two different m/z bins hash to the same bucket? This is called a collision.\nWe handle collisions by adding the intensities together. As we will see in a minute, this is acceptable because it, on average, happens rarely enough that it ‚Äúpreserves similarity‚Äù.\n",
      "cellType": "markdown"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 36,
    "isConflict": false,
    "testId": "row-36",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "# Initialize our final hash vector with all zeros\nhash_vector = [0] * HASH_BUCKETS \n\n# Populate the hash buckets with intensities from our sparse map\nfor sparse_idx, intensity in mz_intensity_map.items():\n    # Map the sparse index to a bucket\n    bucket_idx = hasher(sparse_idx)\n    \n    # Add intensity to that bucket (handles collisions by summation)\n    hash_vector[bucket_idx] += intensity",
      "cellType": "code"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 37,
    "isConflict": false,
    "testId": "row-37",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "The final hash vector\nNotice how the sparse map lets us iterate over only the non-zero entries ‚Äî we never touch the ~88,000 zeros!\n",
      "cellType": "markdown"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 38,
    "isConflict": false,
    "testId": "row-38",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "# Display the hash vector\nnon_zero_buckets = [(i, val) for i, val in enumerate(hash_vector) if val > 0]\n\nprint(f\"Hash vector has {len(non_zero_buckets)} non-zero buckets out of {HASH_BUCKETS} total\\n\")\n\nnonzero_hash_df = pd.DataFrame(non_zero_buckets, columns=['Bucket', 'Intensity'])\npd.set_option('display.float_format', lambda x: f'{x:.2f}')\ndisplay(nonzero_hash_df)",
      "cellType": "code"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 39,
    "isConflict": false,
    "testId": "row-39",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "Step 2 complete! We now have a fixed-size hash vector.\n\n2.6 Summary: The Complete Pipeline\nWe‚Äôve completed the full spectral hashing pipeline:\n\n\n\nStep\nRepresentation\nSize\nLego Analogy\n\n\n\n\nOriginal\n(m/z, intensity) pairs\n24 peaks\nRaw pieces dumped out\n\n\nStep 1: Binning\nSparse dictionary\n24 entries (of 88,000 possible)\nPrecise measurements recorded\n\n\nStep 2: Hashing\nFixed-size vector\n800 dimensions\nConsolidated into practical piles\n\n\n\n\nPutting It All Together: The OMS Workflow\nNow we can see how spectral hashing enables efficient OMS. Define an embedding function:\ndef embed_spectrum(mz_array, intensity_array) -> list[float]:\n    # Step 1: Bin ‚Üí Step 2: Hash\n    return hash_vector  # length 800\n\n\nPhase 1: Build the Library (one-time preprocessing)\n\nFor all spectra with known identity (from a spectral library), imagine we have such a function:\n\nhash_vector_library = embed_spectrum(library_spectrum.mz: list[int], library_spectrum.intensity:list[int])\n\n\nCluster all library hash vectors using cosine similarity.\n\n\nLego analogy: Sort all your known Lego pieces into piles before you start building.\n\n\nPhase 2: Identify Unknown Spectra (query phase)\n\nFor each unknown query spectrum:\n\nhash_vector_query = embed_spectrum(query_spectrum.mz, query_spectrum.intensity)\n\n\n\nFind the nearest cluster representative using cosine similarity.\n\n\nIf similarity exceeds a threshold ‚Üí assign the query the peptide identity of that cluster.\n\n\n\nLego analogy: When you need a piece, check which pile it belongs to. All pieces in that pile share ~ the same identity.\n\n\nWhy does this work for modified peptides?\nA modified peptide shares MOST of its fragment ions with the unmodified version. The modification only shifts a subset of peaks. Because of this shared structure, the hash vectors remain similar enough that modified and unmodified versions cluster together ‚Äî enabling identification regardless of PTMs.\n\nNote: We can only compare vectors of the same length. That‚Äôs why Step 2 (hashing to a fixed 800 dimensions) is essential.\n\n",
      "cellType": "markdown"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 40,
    "isConflict": false,
    "testId": "row-40",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "\n2.7 Similarity Preservation: Does Hashing Actually Work?\nWe‚Äôve claimed that hashing ‚Äúpreserves similarity‚Äù ‚Äî that similar spectra remain similar after compression. Let‚Äôs prove it.\nWhat does ‚Äúpreserve similarity‚Äù mean?\nIf two spectra are similar in the original 88,000-dimensional space, they should also be similar in the compressed 800-dimensional space. The relative ordering of ‚Äúsimilar‚Äù vs. ‚Äúdissimilar‚Äù pairs should remain roughly the same.\n\nLego analogy: If two pieces were in the same ultra-precise category, they should end up in the same (or nearby) practical pile after consolidation.\n\n\nMeasuring similarity with cosine similarity\nWe use the dot product to measure how similar two vectors are:\nx‚Éó‚ãÖz‚Éó>x‚Éó‚ãÖy‚Éó‚ÄÖ‚Ää‚üπ‚ÄÖ‚Ääx‚Éó¬†is¬†more¬†similar¬†to¬†z‚Éó¬†than¬†to¬†y‚Éó\\vec{x} \\cdot \\vec{z} > \\vec{x} \\cdot \\vec{y} \\implies \\vec{x} \\text{ is more similar to } \\vec{z} \\text{ than to } \\vec{y}\nx‚ãÖz>x‚ãÖy‚Äã‚üπx¬†is¬†more¬†similar¬†to¬†z¬†than¬†to¬†y‚Äã\nCosine similarity is just a normalized dot product (scaled between -1 and 1, like‚Ä¶cosine!).\nExample:\nx‚Éó=[0,500,0,1200](Spectrum¬†A)\\vec{x} = [0, 500, 0, 1200] \\quad \\text{(Spectrum A)}x=[0,500,0,1200](Spectrum¬†A)\nz‚Éó=[0,480,0,1190](Spectrum¬†B¬†‚Äî¬†similar)\\vec{z} = [0, 480, 0, 1190] \\quad \\text{(Spectrum B ‚Äî similar)}z=[0,480,0,1190](Spectrum¬†B¬†‚Äî¬†similar)\ny‚Éó=[100,30,2000,0](Spectrum¬†C¬†‚Äî¬†different)\\vec{y} = [100, 30, 2000, 0] \\quad \\text{(Spectrum C ‚Äî different)}y‚Äã=[100,30,2000,0](Spectrum¬†C¬†‚Äî¬†different)\nDot products:\nx‚Éó‚ãÖz‚Éó=(0)(0)+(500)(480)+(0)(0)+(1200)(1190)=1,668,000\\vec{x} \\cdot \\vec{z} = (0)(0) + (500)(480) + (0)(0) + (1200)(1190) = 1,668,000x‚ãÖz=(0)(0)+(500)(480)+(0)(0)+(1200)(1190)=1,668,000\nx‚Éó‚ãÖy‚Éó=(0)(100)+(500)(30)+(0)(2000)+(1200)(0)=15,000\\vec{x} \\cdot \\vec{y} = (0)(100) + (500)(30) + (0)(2000) + (1200)(0) = 15,000x‚ãÖy‚Äã=(0)(100)+(500)(30)+(0)(2000)+(1200)(0)=15,000\nSince 1,668,000‚â´15,0001,668,000 \\gg 15,0001,668,000‚â´15,000, spectra A and B would be clustered together.\n\nClick to see the full cosine similarity formula\ncos‚Å°(Œ∏)=x‚Éó‚ãÖz‚Éó‚à£x‚Éó‚à£‚à£z‚Éó‚à£\\cos(\\theta) = \\frac{\\vec{x} \\cdot \\vec{z}}{|\\vec{x}| |\\vec{z}|}\ncos(Œ∏)=‚à£x‚à£‚à£z‚à£x‚ãÖz‚Äã\nwhere Œ∏\\thetaŒ∏ is the angle between vectors. When Œ∏=0¬∞\\theta = 0¬∞Œ∏=0¬∞ (identical direction), cos‚Å°(Œ∏)=1\\cos(\\theta) = 1cos(Œ∏)=1. When Œ∏=90¬∞\\theta = 90¬∞Œ∏=90¬∞ (perpendicular), cos‚Å°(Œ∏)=0\\cos(\\theta) = 0cos(Œ∏)=0.\n",
      "cellType": "markdown"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 41,
    "isConflict": false,
    "testId": "row-41",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "Click play to go through a visual example (no sound), starting from the top.\n\n  \n\n",
      "cellType": "markdown"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 42,
    "isConflict": false,
    "testId": "row-42",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "\nNote: Some similarity loss is expected due to hash collisions, but this loss is typically small and acceptable for clustering purposes.\n\n",
      "cellType": "markdown"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 43,
    "isConflict": false,
    "testId": "row-43",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "Empirical validation\nThe code below compares pairwise similarities between spectra in both the original (sparse) and hashed representations. If hashing works, the correlation should be high.\nIn simpler terms, did you notice that when we went from binned -> binned + hashed spectra, the peaks didn‚Äôt keep their original spots? We‚Äôll show that a hash function actually does this so reliably, that we still KEEP the similarity or dissimilarity property of the original binned spectra.\n\nAgain, we are not comparing binned spectra to binned + hashed, we‚Äôre following the video exactly, and ensuring that if 2 binned spectra are similar, then their respective hashed versions will also be similar.\n\nLike aforementioned, you also cannot actually compare two lists of 80,000 (binned) and 800 (binned + hashed) elements. This is another reason why we compare things in their respective ‚Äúspaces.‚Äù\n\n\n\n",
      "cellType": "markdown"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 44,
    "isConflict": false,
    "testId": "row-44",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "prove_similarity_preservation_plots_and_statistics(\"04-17-23_CA_Tryp_HCD_10min_CLEAN.mzML\") \n# This is a very computationally expensive task, we use a snippet of the original file for the sake of time",
      "cellType": "code"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 45,
    "isConflict": false,
    "testId": "row-45",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "\nWorked Example: Spectral Hashing End-to-End\nNow let‚Äôs see the complete pipeline on real data. We‚Äôll work with the peptide AVVQDPALKPLALVYGEATSR.\nBelow is its theoretical ion ladder:\n",
      "cellType": "markdown"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 46,
    "isConflict": false,
    "testId": "row-46",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "make_ion_ladder('AVVQDPALKPLALVYGEATSR')",
      "cellType": "code"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 47,
    "isConflict": false,
    "testId": "row-47",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "Let‚Äôs look at how this ion ladder can be plotted as a spectrum. The purpose of this is to visualize the spread of m/z values. The intensity values here are meaningless.\n",
      "cellType": "markdown"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 48,
    "isConflict": true,
    "testId": "conflict-row-4",
    "base": {
      "exists": true,
      "content": "b_mz = [\n    72.044114, 171.112528, 270.180942, 398.239520, 513.266463,\n    610.319227, 681.356341, 794.440405, 922.535368, 1019.588132,\n    1132.672196, 1203.709310, 1316.793374, 1415.861788, 1578.925108,\n    1635.946572, 1764.989165, 1836.026279, 1937.073958, 2024.105986\n]\ny_mz = [\n    2127.179698, 2028.111284, 1929.042870, 1800.984292, 1685.957349,\n    1588.904585, 1517.867471, 1404.783407, 1276.688444, 1179.635680,\n    1066.551616, 995.514502, 882.430438, 783.362024, 620.298704,\n    563.277240, 434.234647, 363.197533, 262.149854, 175.117826\n]\nfig, ax = plt.subplots(figsize=(8, 4), dpi=100)\n# Equal heights (e.g., 1.0)\nheight = 0.6\nax.vlines(b_mz, 0, height, colors='#1976D2', linewidth=1.5, label='b-ions')\nax.vlines(y_mz, 0, height, colors='#D32F2F',  linewidth=1.5, label='y-ions')\nax.set_ylim(0, 1.1)\nax.set_xlabel(\"m/z\")\nax.set_ylabel(\"Intensity (arbitrary)\")\nax.set_title(\"Theoretical ion ladder for AVVQDPALKPLALVYGEATSR\")\nax.legend(frameon=False)\nax.grid(True, axis='y', alpha=0.25)\n# b labels: b1, b3, b5, ...\nfor i, x in enumerate(b_mz, start=1):\n    if i % 2 == 1:\n        ax.text(x, height*1.02, f\"b{i}\", rotation=90, ha=\"center\", va=\"bottom\", fontsize=8)\n# y_mz is descending (y20..y1). Convert to ion number j = y#\nn_y = len(y_mz)\nfor i, x in enumerate(y_mz, start=1):\n    j = n_y - i + 1   # y ion number at this m/z\n    if j % 2 == 1:    # y1, y3, y5, ...\n        ax.text(x, height*1.02, f\"y{j}\", rotation=90, ha=\"center\", va=\"bottom\", fontsize=8)\nplt.show()",
      "cellType": "code"
    },
    "current": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "incoming": {
      "exists": true,
      "content": "b_mz = [\n    72.044114, 171.112528, 270.180942, 398.239520, 513.266463,\n    610.319227, 681.356341, 794.440405, 922.535368, 1019.588132,\n    1132.672196, 1203.709310, 1316.793374, 1415.861788, 1578.925108,\n    1635.946572, 1764.989165, 1836.026279, 1937.073958, 2024.105986\n]\ny_mz = [\n    2127.179698, 2028.111284, 1929.042870, 1800.984292, 1685.957349,\n    1588.904585, 1517.867471, 1404.783407, 1276.688444, 1179.635680,\n    1066.551616, 995.514502, 882.430438, 783.362024, 620.298704,\n    563.277240, 434.234647, 363.197533, 262.149854, 175.117826\n]\nfig, ax = plt.subplots(figsize=(8, 4), dpi=100)\n# Equal heights (e.g., 1.0)\nheight = 0.6\nax.vlines(b_mz, 0, height, colors='#1976D2', linewidth=1.5, label='b-ions')\nax.vlines(y_mz, 0, height, colors='#D32F2F',  linewidth=1.5, label='y-ions')\nax.set_ylim(0, 1.1)\nax.set_xlabel(\"m/z\")\nax.set_ylabel(\"Intensity (arbitrary)\")\nax.set_title(\"Theoretical ion ladder for AVVQDPALKPLALVYGEATSR\")\nax.legend(frameon=False)\nax.grid(True, axis='y', alpha=0.25)\n# b labels: b1, b3, b5, ...\nfor i, x in enumerate(b_mz, start=1):\n    if i % 2 == 1:\n        ax.text(x, height*1.02, f\"b{i}\", rotation=90, ha=\"center\", va=\"bottom\", fontsize=8)\n# y_mz is descending (y20..y1). Convert to ion number j = y#\nn_y = len(y_mz)\nfor i, x in enumerate(y_mz, start=1):\n    j = n_y - i + 1   # y ion number at this m/z\n    if j % 2 == 1:    # y1, y3, y5, ...\n        ax.text(x, height*1.02, f\"y{j}\", rotation=90, ha=\"center\", va=\"bottom\", fontsize=8)\nplt.show()",
      "cellType": "code"
    }
  },
  {
    "rowIndex": 49,
    "isConflict": true,
    "testId": "conflict-row-5",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "b_mz = [\n    72.044114, 171.112528, 270.180942, 398.239520, 513.266463,\n    610.319227, 681.356341, 794.440405, 922.535368, 1019.588132,\n    1132.672196, 1203.709310, 1316.793374, 1415.861788, 1578.925108,\n    1635.946572, 1764.989165, 1836.026279, 1937.073958, 2024.105986\n]\n\ny_mz = [\n    2127.179698, 2028.111284, 1929.042870, 1800.984292, 1685.957349,\n    1588.904585, 1517.867471, 1404.783407, 1276.688444, 1179.635680,\n    1066.551616, 995.514502, 882.430438, 783.362024, 620.298704,\n    563.277240, 434.234647, 363.197533, 262.149854, 175.117826\n]\n\nplot_theoretical_ions(b_mz, y_mz, 'AVVQDPALKPLALVYGEATSR')",
      "cellType": "code"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 50,
    "isConflict": true,
    "testId": "conflict-row-6",
    "base": {
      "exists": true,
      "content": "Now that we‚Äôve visualized this theoretical ion ladder as a ‚Äúspectrum,‚Äù let‚Äôs plot a real spectrum and use the ion ladder to annotate it. The spectrum plotted below is the unmodified AVVQDPALKPLALVYGEATSR peptide.\n",
      "cellType": "markdown"
    },
    "current": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "incoming": {
      "exists": true,
      "content": "Now that we‚Äôve visualized this theoretical ion ladder as a ‚Äúspectrum,‚Äù let‚Äôs plot a real spectrum and use the ion ladder to annotate it. The spectrum plotted below is the unmodified AVVQDPALKPLALVYGEATSR peptide.\n",
      "cellType": "markdown"
    }
  },
  {
    "rowIndex": 51,
    "isConflict": true,
    "testId": "conflict-row-7",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "Now let‚Äôs plot a real spectrum and use the theoretical ions above to to annotate it. We‚Äôll start with scan 9970, the spectrum of the unmodified AVVQDPALKPLALVYGEATSR peptide.\n",
      "cellType": "markdown"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 52,
    "isConflict": true,
    "testId": "conflict-row-8",
    "base": {
      "exists": true,
      "content": "plot_MS2(get_MS2_object(full_calibrated_mzml_path, 9970, peptide = 'AVVQDPALKPLALVYGEATSR')) # Scan 9970 is the unmodified spectrum for sequence AVVQDPALKPLALVYGEATSR",
      "cellType": "code"
    },
    "current": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "incoming": {
      "exists": true,
      "content": "plot_MS2(get_MS2_object(full_calibrated_mzml_path, 9970, peptide = 'AVVQDPALKPLALVYGEATSR')) # Scan 9970 is the unmodified spectrum for sequence AVVQDPALKPLALVYGEATSR",
      "cellType": "code"
    }
  },
  {
    "rowIndex": 53,
    "isConflict": true,
    "testId": "conflict-row-9",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "plot_MS2(get_MS2_object(full_calibrated_mzml_path, 9970, peptide = 'AVVQDPALKPLALVYGEATSR'))",
      "cellType": "code"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 54,
    "isConflict": false,
    "testId": "row-54",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "Although there is inevitable noise (un-annotated peaks) that deviates from the theoretical ions, this spectrum overall aligns really well with the unmodified AVVQDPALKPLALVYGEATSR peptide. In other words, a significant proportion of this spectrum‚Äôs total intensity is accounted for by its peptide‚Äôs theoretical ions. Let‚Äôs look at a modified version of the peptide.\n",
      "cellType": "markdown"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 55,
    "isConflict": true,
    "testId": "conflict-row-10",
    "base": {
      "exists": true,
      "content": "seq = 'AVVQDPALKPLALVYGEATSR'\nspec_left  = get_MS2_object(full_calibrated_mzml_path, 9970, peptide=seq)\nspec_right = get_MS2_object(full_calibrated_mzml_path, 8090, peptide=seq)\n\n# Make two panels sharing axes so scales match\nfig, axes = plt.subplots(1, 2, figsize=(14, 5), dpi=120, sharex=True, sharey=True)\naxes[0].set_xlabel(\"m/z\")\naxes[0].set_ylabel(\"Intensity\")\n# Left panel = unmodified = scan 9970\nsup.spectrum(spec_left, ax=axes[0], grid=True)\naxes[0].set_title(\"Unmodified (Scan 9970)\")\n# Right panel = modified = scan 8090\nsup.spectrum(spec_right, ax=axes[1], grid=True)\naxes[1].set_title(\"Modified (Scan 8090)\")\nfig.suptitle(\"AVVQDPALKPLALVYGEATSR ‚Äî Unmodified vs. Modified\", fontsize=14)\nplt.tight_layout(rect=[0, 0, 1, 0.94])  # leave space at the top for the suptitle\nplt.show()",
      "cellType": "code"
    },
    "current": {
      "exists": true,
      "content": "seq = 'AVVQDPALKPLALVYGEATSR'\nspec_left  = get_MS2_object(full_calibrated_mzml_path, 9970, peptide=seq) #AVVQDPALKPLALVYGEATSR\nspec_right = get_MS2_object(full_calibrated_mzml_path, 8090, peptide=seq) #AVVQ[Common Artifact:Deamidation on Q]DPALKPLALVYGEATSR\n# Make two panels with shared axes\nfig, axes = plt.subplots(1, 2, figsize=(14, 5), dpi=120, sharex=True, sharey=True)\naxes[0].set_xlabel(\"m/z\")\naxes[0].set_ylabel(\"Intensity\")\n# Left panel = scan 9970 (unmodified peptide)\nsup.spectrum(spec_left, ax=axes[0], grid=True)\naxes[0].set_title(\"Unmodified (Scan 9970)\")\n# Right panel = scan 8090 (modified peptide)\nsup.spectrum(spec_right, ax=axes[1], grid=True)\naxes[1].set_title(\"Modified (Scan 8090)\")\nfig.suptitle(\"AVVQDPALKPLALVYGEATSR ‚Äî Unmodified vs. Modified\", fontsize=14)\nplt.tight_layout(rect=[0, 0, 1, 0.94])  # leave space at top\nplt.show()",
      "cellType": "code"
    },
    "incoming": {
      "exists": true,
      "content": "seq = 'AVVQDPALKPLALVYGEATSR'\nspec_left  = get_MS2_object(full_calibrated_mzml_path, 9970, peptide=seq)\nspec_right = get_MS2_object(full_calibrated_mzml_path, 8090, peptide=seq)\n\n# Make two panels sharing axes so scales match\nfig, axes = plt.subplots(1, 2, figsize=(14, 5), dpi=120, sharex=True, sharey=True)\naxes[0].set_xlabel(\"m/z\")\naxes[0].set_ylabel(\"Intensity\")\n# Left panel = unmodified = scan 9970\nsup.spectrum(spec_left, ax=axes[0], grid=True)\naxes[0].set_title(\"Unmodified (Scan 9970)\")\n# Right panel = modified = scan 8090\nsup.spectrum(spec_right, ax=axes[1], grid=True)\naxes[1].set_title(\"Modified (Scan 8090)\")\nfig.suptitle(\"AVVQDPALKPLALVYGEATSR ‚Äî Unmodified vs. Modified\", fontsize=14)\nplt.tight_layout(rect=[0, 0, 1, 0.94])  # leave space at the top for the suptitle\nplt.show()",
      "cellType": "code"
    }
  },
  {
    "rowIndex": 56,
    "isConflict": false,
    "testId": "row-56",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "We can repeat that process using an unmodified and modified spectrum from 2 other peptides in our mzml file: IITHPNFNGNTLDNDIMLIK and RMVNNGHSFNVEYDDSQDK.\n",
      "cellType": "markdown"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 57,
    "isConflict": true,
    "testId": "conflict-row-11",
    "base": {
      "exists": true,
      "content": "seq = 'IITHPNFNGNTLDNDIMLIK'\nspec_left  = get_MS2_object(full_calibrated_mzml_path, 7567, peptide=seq)\nspec_right = get_MS2_object(full_calibrated_mzml_path, 8616, peptide=seq)\n# Make two panels sharing axes so scales match\nfig, axes = plt.subplots(1, 2, figsize=(14, 5), dpi=120, sharex=True, sharey=True)\naxes[0].set_xlabel(\"m/z\")\naxes[0].set_ylabel(\"Intensity\")\n# Left panel = unmodified = scan 7567\nsup.spectrum(spec_left, ax=axes[0], grid=True)\naxes[0].set_title(\"Unmodified (Scan 7567)\")\n# Right panel = modified = scan 8616\nsup.spectrum(spec_right, ax=axes[1], grid=True)\naxes[1].set_title(\"Modified (Scan 8616)\")\nfig.suptitle(\"IITHPNFNGNTLDNDIMLIK ‚Äî Unmodified vs. Modified\", fontsize=14)\nplt.tight_layout(rect=[0, 0, 1, 0.94])  # leave space at the top for the suptitle\nplt.show()",
      "cellType": "code"
    },
    "current": {
      "exists": true,
      "content": "seq = 'IITHPNFNGNTLDNDIMLIK'\nspec_left  = get_MS2_object(full_calibrated_mzml_path, 7567, peptide=seq) #IITHPNFNGNTLDNDIMLIK\nspec_right = get_MS2_object(full_calibrated_mzml_path, 8616, peptide=seq) #[Common Artifact:Carbamyl on X]IITHPNFNGNTLDNDIMLIK\nfig, axes = plt.subplots(1, 2, figsize=(14, 5), dpi=120, sharex=True, sharey=True)\naxes[0].set_xlabel(\"m/z\")\naxes[0].set_ylabel(\"Intensity\")\n# Left panel = scan 7567 (unmodified)\nsup.spectrum(spec_left, ax=axes[0], grid=True)\naxes[0].set_title(\"Unmodified (Scan 7567)\")\n# Right panel = scan 8616 (modified)\nsup.spectrum(spec_right, ax=axes[1], grid=True)\naxes[1].set_title(\"Modified (Scan 8616)\")\nfig.suptitle(\"IITHPNFNGNTLDNDIMLIK ‚Äî Unmodified vs. Modified\", fontsize=14)\nplt.tight_layout(rect=[0, 0, 1, 0.94])\nplt.show()",
      "cellType": "code"
    },
    "incoming": {
      "exists": true,
      "content": "seq = 'IITHPNFNGNTLDNDIMLIK'\nspec_left  = get_MS2_object(full_calibrated_mzml_path, 7567, peptide=seq)\nspec_right = get_MS2_object(full_calibrated_mzml_path, 8616, peptide=seq)\n# Make two panels sharing axes so scales match\nfig, axes = plt.subplots(1, 2, figsize=(14, 5), dpi=120, sharex=True, sharey=True)\naxes[0].set_xlabel(\"m/z\")\naxes[0].set_ylabel(\"Intensity\")\n# Left panel = unmodified = scan 7567\nsup.spectrum(spec_left, ax=axes[0], grid=True)\naxes[0].set_title(\"Unmodified (Scan 7567)\")\n# Right panel = modified = scan 8616\nsup.spectrum(spec_right, ax=axes[1], grid=True)\naxes[1].set_title(\"Modified (Scan 8616)\")\nfig.suptitle(\"IITHPNFNGNTLDNDIMLIK ‚Äî Unmodified vs. Modified\", fontsize=14)\nplt.tight_layout(rect=[0, 0, 1, 0.94])  # leave space at the top for the suptitle\nplt.show()",
      "cellType": "code"
    }
  },
  {
    "rowIndex": 58,
    "isConflict": true,
    "testId": "conflict-row-12",
    "base": {
      "exists": true,
      "content": "seq = 'RMVNNGHSFNVEYDDSQDK'\nspec_left  = get_MS2_object(full_calibrated_mzml_path, 3864, peptide=seq)\nspec_right = get_MS2_object(full_calibrated_mzml_path, 4022, peptide=seq)\n\n# Make two panels sharing axes so scales match\nfig, axes = plt.subplots(1, 2, figsize=(14, 5), dpi=120, sharex=True, sharey=True)\naxes[0].set_xlabel(\"m/z\")\naxes[0].set_ylabel(\"Intensity\")\n# Left panel = unmodified = scan 3864\nsup.spectrum(spec_left, ax=axes[0], grid=True)\naxes[0].set_title(\"Unmodified (Scan 3864)\")\n# Right panel = modified = scan 4022\nsup.spectrum(spec_right, ax=axes[1], grid=True)\naxes[1].set_title(\"Modified (Scan 4022)\")\nfig.suptitle(\"RMVNNGHSFNVEYDDSQDK ‚Äî Unmodified vs. Modified\", fontsize=14)\nplt.tight_layout(rect=[0, 0, 1, 0.94])  # leave space at the top for the suptitle\nplt.show()",
      "cellType": "code"
    },
    "current": {
      "exists": true,
      "content": "seq = 'RMVNNGHSFNVEYDDSQDK'\nspec_left  = get_MS2_object(full_calibrated_mzml_path, 3864, peptide=seq) #RMVNNGHSFNVEYDDSQDK\nspec_right = get_MS2_object(full_calibrated_mzml_path, 4022, peptide=seq) #RMVNN[Common Artifact:Deamidation on N]GHSFNVEYDDSQDK\n# Make two panels with shared zxes\nfig, axes = plt.subplots(1, 2, figsize=(14, 5), dpi=120, sharex=True, sharey=True)\naxes[0].set_xlabel(\"m/z\")\naxes[0].set_ylabel(\"Intensity\")\n# Left panel = scan 3864 (unmodified)\nsup.spectrum(spec_left, ax=axes[0], grid=True)\naxes[0].set_title(\"Unmodified (Scan 3864)\")\n# Right panel = scan 4022 (modified)\nsup.spectrum(spec_right, ax=axes[1], grid=True)\naxes[1].set_title(\"Modified (Scan 4022)\")\nfig.suptitle(\"RMVNNGHSFNVEYDDSQDK ‚Äî Unmodified vs. Modified\", fontsize=14)\nplt.tight_layout(rect=[0, 0, 1, 0.94])\nplt.show()",
      "cellType": "code"
    },
    "incoming": {
      "exists": true,
      "content": "seq = 'RMVNNGHSFNVEYDDSQDK'\nspec_left  = get_MS2_object(full_calibrated_mzml_path, 3864, peptide=seq)\nspec_right = get_MS2_object(full_calibrated_mzml_path, 4022, peptide=seq)\n\n# Make two panels sharing axes so scales match\nfig, axes = plt.subplots(1, 2, figsize=(14, 5), dpi=120, sharex=True, sharey=True)\naxes[0].set_xlabel(\"m/z\")\naxes[0].set_ylabel(\"Intensity\")\n# Left panel = unmodified = scan 3864\nsup.spectrum(spec_left, ax=axes[0], grid=True)\naxes[0].set_title(\"Unmodified (Scan 3864)\")\n# Right panel = modified = scan 4022\nsup.spectrum(spec_right, ax=axes[1], grid=True)\naxes[1].set_title(\"Modified (Scan 4022)\")\nfig.suptitle(\"RMVNNGHSFNVEYDDSQDK ‚Äî Unmodified vs. Modified\", fontsize=14)\nplt.tight_layout(rect=[0, 0, 1, 0.94])  # leave space at the top for the suptitle\nplt.show()",
      "cellType": "code"
    }
  },
  {
    "rowIndex": 59,
    "isConflict": false,
    "testId": "row-59",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "There are two trends you might be noticing across these spectra:\n\nGenerally, when a modified or unmodified peptide‚Äôs spectrum is annotated with the theoretical ions for it‚Äôs associated unmodified peptide, there is a significant proportion of that spectrum‚Äôs intensity accounted for by the theoretical ions.\nUnmodified spectra better ‚Äúmatch‚Äù/are better accounted for by the unmodified peptide‚Äôs theoretical ions than modified spectra. But there is not an extrememly noticeable difference.\n\nWhat if we were to use the theoretical ions of one peptide to annotate the spectrum of another? Let‚Äôs try using the theoretical ions from AVVQDPALKPLALVYGEATSR to annotate the spectrum of the RMVNNGHSFNVEYDDSQDK peptide. We‚Äôll plot that on the right side. On the left, we‚Äôll plot the spectrum of a modified AVVQDPALKPLALVYGEATSR spectrum and annotate it with the AVVQDPALKPLALVYGEATSR ions (just like earlier).\n\nIn short, we are plotting spectra from 2 different base peptides and annotating them using the theoretical ions from only 1 peptide.\n",
      "cellType": "markdown"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 60,
    "isConflict": true,
    "testId": "conflict-row-13",
    "base": {
      "exists": true,
      "content": "seq = 'AVVQDPALKPLALVYGEATSR'\n\nspec_left  = get_MS2_object(full_calibrated_mzml_path, 8090, peptide=seq)\nspec_right = get_MS2_object(full_calibrated_mzml_path, 4022, peptide=seq)\n# Make two panels sharing axes so scales match\nfig, axes = plt.subplots(1, 2, figsize=(14, 5), dpi=120, sharex=True, sharey=True)\naxes[0].set_xlabel(\"m/z\")\naxes[0].set_ylabel(\"Intensity\")\n# Left panel = modified AVVQDPALKPLALVYGEATSR = scan 8090\nsup.spectrum(spec_left, ax=axes[0], grid=True)\naxes[0].set_title(\"Modified AVVQDPALKPLALVYGEATSR (scan 8090)\")\n# Right panel = modified RMVNNGHSFNVEYDDSQDK = scan 4022\nsup.spectrum(spec_right, ax=axes[1], grid=True)\naxes[1].set_title(\"Modified RMVNNGHSFNVEYDDSQDK (Scan 4022)\")\nfig.suptitle(\"Annotation from AVVQDPALKPLALVYGEATSR Ion Ladder\", fontsize=14)\nplt.tight_layout(rect=[0, 0, 1, 0.94])  # leave space at the top for the suptitle\nplt.show()",
      "cellType": "code"
    },
    "current": {
      "exists": true,
      "content": "seq = 'AVVQDPALKPLALVYGEATSR'\nspec_left  = get_MS2_object(full_calibrated_mzml_path, 8090, peptide=seq)\nspec_right = get_MS2_object(full_calibrated_mzml_path, 3864, peptide=seq)\n# Make two panels with shared axes\nfig, axes = plt.subplots(1, 2, figsize=(14, 5), dpi=120, sharex=True, sharey=True)\naxes[0].set_xlabel(\"m/z\")\naxes[0].set_ylabel(\"Intensity\")\n# Left panel = modified AVVQDPALKPLALVYGEATSR = scan 8090\nsup.spectrum(spec_left, ax=axes[0], grid=True)\naxes[0].set_title(\"Modified AVVQDPALKPLALVYGEATSR (scan 8090)\")\n# Right panel = unmodified RMVNNGHSFNVEYDDSQDK = scan 3864\nsup.spectrum(spec_right, ax=axes[1], grid=True)\naxes[1].set_title(\"Unmodified RMVNNGHSFNVEYDDSQDK (Scan 3864)\")\nfig.suptitle(\"Annotation by AVVQDPALKPLALVYGEATS's Theoretical Ions\", fontsize=14)\nplt.tight_layout(rect=[0, 0, 1, 0.94])  # leave space at the top for the suptitle\nplt.show()",
      "cellType": "code"
    },
    "incoming": {
      "exists": true,
      "content": "seq = 'AVVQDPALKPLALVYGEATSR'\n\nspec_left  = get_MS2_object(full_calibrated_mzml_path, 8090, peptide=seq)\nspec_right = get_MS2_object(full_calibrated_mzml_path, 4022, peptide=seq)\n# Make two panels sharing axes so scales match\nfig, axes = plt.subplots(1, 2, figsize=(14, 5), dpi=120, sharex=True, sharey=True)\naxes[0].set_xlabel(\"m/z\")\naxes[0].set_ylabel(\"Intensity\")\n# Left panel = modified AVVQDPALKPLALVYGEATSR = scan 8090\nsup.spectrum(spec_left, ax=axes[0], grid=True)\naxes[0].set_title(\"Modified AVVQDPALKPLALVYGEATSR (scan 8090)\")\n# Right panel = modified RMVNNGHSFNVEYDDSQDK = scan 4022\nsup.spectrum(spec_right, ax=axes[1], grid=True)\naxes[1].set_title(\"Modified RMVNNGHSFNVEYDDSQDK (Scan 4022)\")\nfig.suptitle(\"Annotation from AVVQDPALKPLALVYGEATSR Ion Ladder\", fontsize=14)\nplt.tight_layout(rect=[0, 0, 1, 0.94])  # leave space at the top for the suptitle\nplt.show()",
      "cellType": "code"
    }
  },
  {
    "rowIndex": 61,
    "isConflict": true,
    "testId": "conflict-row-14",
    "base": {
      "exists": true,
      "content": "Let‚Äôs do that once more, but this time annotating the spectrum of the modified RMVNNGHSFNVEYDDSQDK peptide using the theoretical ion ladder of RMVNNGHSFNVEYDDSQDK (on the left) and AVVQDPALKPLALVYGEATSR (on the right). In this case, we are plotting 1 spectrum and annotating it with 2 different ion ladders.\n",
      "cellType": "markdown"
    },
    "current": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "incoming": {
      "exists": true,
      "content": "Let‚Äôs do that once more, but this time annotating the spectrum of the modified RMVNNGHSFNVEYDDSQDK peptide using the theoretical ion ladder of RMVNNGHSFNVEYDDSQDK (on the left) and AVVQDPALKPLALVYGEATSR (on the right). In this case, we are plotting 1 spectrum and annotating it with 2 different ion ladders.\n",
      "cellType": "markdown"
    }
  },
  {
    "rowIndex": 62,
    "isConflict": true,
    "testId": "conflict-row-15",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "Now we‚Äôll annotate the spectrum of the modified RMVNNGHSFNVEYDDSQDK peptide using the theoretical ions of RMVNNGHSFNVEYDDSQDK (on the left) and AVVQDPALKPLALVYGEATSR (on the right).We are plotting 1 spectrum and annotating it using 2 different theoretical ions from 2 different base peptides.\n",
      "cellType": "markdown"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 63,
    "isConflict": true,
    "testId": "conflict-row-16",
    "base": {
      "exists": true,
      "content": "seq_1= 'RMVNNGHSFNVEYDDSQDK'\nseq_2 = 'AVVQDPALKPLALVYGEATSR'\nspec_left  = get_MS2_object(full_calibrated_mzml_path, 4022, peptide=seq_1)\nspec_right = get_MS2_object(full_calibrated_mzml_path, 4022, peptide=seq_2)\n# Make two panels sharing axes so scales match\nfig, axes = plt.subplots(1, 2, figsize=(14, 5), dpi=120, sharex=True, sharey=True)\naxes[0].set_xlabel(\"m/z\")\naxes[0].set_ylabel(\"Intensity\")\n# Left panel = RMVNNGHSFNVEYDDSQDK Annotation, Scan 4022\nsup.spectrum(spec_left, ax=axes[0], grid=True)\naxes[0].set_title(\"RMVNNGHSFNVEYDDSQDK Annotation\")\n# Right panel = AVVQDPALKPLALVYGEATSR Annotation, scan 4022\nsup.spectrum(spec_right, ax=axes[1], grid=True)\naxes[1].set_title(\"AVVQDPALKPLALVYGEATSR Annotation\")\nfig.suptitle(\"Modified RMVNNGHSFNVEYDDSQDK Spectrum\", fontsize=14)\nplt.tight_layout(rect=[0, 0, 1, 0.94])  # leave space at the top for the suptitle\nplt.show()",
      "cellType": "code"
    },
    "current": {
      "exists": true,
      "content": "seq_1= 'RMVNNGHSFNVEYDDSQDK'\nseq_2 = 'AVVQDPALKPLALVYGEATSR'\nspec_left  = get_MS2_object(full_calibrated_mzml_path, 4022, peptide=seq_1)\nspec_right = get_MS2_object(full_calibrated_mzml_path, 4022, peptide=seq_2)\n# Make two panels with shared axes\nfig, axes = plt.subplots(1, 2, figsize=(14, 5), dpi=120, sharex=True, sharey=True)\naxes[0].set_xlabel(\"m/z\")\naxes[0].set_ylabel(\"Intensity\")\n# Left panel = RMVNNGHSFNVEYDDSQDK Annotation, Scan 4022\nsup.spectrum(spec_left, ax=axes[0], grid=True)\naxes[0].set_title(\"RMVNNGHSFNVEYDDSQDK Annotation\")\n# Right panel = AVVQDPALKPLALVYGEATSR Annotation, scan 4022\nsup.spectrum(spec_right, ax=axes[1], grid=True)\naxes[1].set_title(\"AVVQDPALKPLALVYGEATSR Annotation\")\nfig.suptitle(\"Modified RMVNNGHSFNVEYDDSQDK Spectrum\", fontsize=14)\nplt.tight_layout(rect=[0, 0, 1, 0.94])\nplt.show()",
      "cellType": "code"
    },
    "incoming": {
      "exists": true,
      "content": "seq_1= 'RMVNNGHSFNVEYDDSQDK'\nseq_2 = 'AVVQDPALKPLALVYGEATSR'\nspec_left  = get_MS2_object(full_calibrated_mzml_path, 4022, peptide=seq_1)\nspec_right = get_MS2_object(full_calibrated_mzml_path, 4022, peptide=seq_2)\n# Make two panels sharing axes so scales match\nfig, axes = plt.subplots(1, 2, figsize=(14, 5), dpi=120, sharex=True, sharey=True)\naxes[0].set_xlabel(\"m/z\")\naxes[0].set_ylabel(\"Intensity\")\n# Left panel = RMVNNGHSFNVEYDDSQDK Annotation, Scan 4022\nsup.spectrum(spec_left, ax=axes[0], grid=True)\naxes[0].set_title(\"RMVNNGHSFNVEYDDSQDK Annotation\")\n# Right panel = AVVQDPALKPLALVYGEATSR Annotation, scan 4022\nsup.spectrum(spec_right, ax=axes[1], grid=True)\naxes[1].set_title(\"AVVQDPALKPLALVYGEATSR Annotation\")\nfig.suptitle(\"Modified RMVNNGHSFNVEYDDSQDK Spectrum\", fontsize=14)\nplt.tight_layout(rect=[0, 0, 1, 0.94])  # leave space at the top for the suptitle\nplt.show()",
      "cellType": "code"
    }
  },
  {
    "rowIndex": 64,
    "isConflict": false,
    "testId": "row-64",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "You‚Äôre hopefully noticing a much more dramatic trend now. In the first example, where we annotated two different spectra (from different base peptides) using the same theoretical ions (from only one base peptide), a much greater proportion of the ‚Äúmatching‚Äù spectrum‚Äôs intensity was accounted for by the theoretical ions than of the other spectrum‚Äôs intensity. In the second example, where we annotated the same spectrum using two different sets of theoretical ions (one belonging to the ‚Äúmatching‚Äù peptide, and one not), a much greater proportion of the spectrum (annotated by it‚Äôs matching peptide)'s intensity was accounted for by the ions than of the spectrum (annoted by the other peptide)'s intensity.\n\nNow, we can actually begin binning our spectrum!\n",
      "cellType": "markdown"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 65,
    "isConflict": false,
    "testId": "row-65",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "\nimport importlib\nimport SpectrumWithTransformations as swt_module\nimport SpectrumWithTransformations\n\nimportlib.reload(swt_module)\n\n# This function should read in an mzml file and return an object of type SpectrumWithTransformations\n# Based off of get_MS2_object from Sam Payne lesson 4\ndef get_SWT_object(\n    mzml_path: str,\n    scan_number: int,\n    full_sequence = None,\n) -> \"SpectrumWithTransformations\":\n    \n    index = scan_number -1 #scan_number is 1-based, index is 0-based\n    with mzml.MzML(mzml_path, use_index=True) as reader: #use_index=True allows us to avoid reading through the entire mzml file\n        selected_spectrum = reader.get_by_index(index)\n    # Test to see if we accessed the correct scan: PASSED!\n    # precursor_mz = selected_spectrum['precursorList']['precursor'][0]['isolationWindow']['isolation window target m/z']\n    # print(precursor_mz)\n    \n\n    # This finds the cooresponding values in the .mzml file to create our MS2 for a given scan (see the params)\n    spectrum_id = selected_spectrum['id']\n    retention_time = selected_spectrum['scanList']['scan'][0]['scan start time']\n    precursor_mz = selected_spectrum['precursorList']['precursor'][0]['isolationWindow']['isolation window target m/z']\n    precursor_charge = int(selected_spectrum['precursorList']['precursor'][0]['selectedIonList']['selectedIon'][0]['charge state'])\n    mz_array = np.asarray(selected_spectrum['m/z array'])\n    intensity_array = np.asarray(selected_spectrum['intensity array'])\n    \n    swt_object = SpectrumWithTransformations.SpectrumWithTransformations(\n        identifier=spectrum_id,\n        scan_number=scan_number,\n        precursor_mz=precursor_mz,\n        precursor_charge=precursor_charge,\n        mz_array=mz_array,\n        intensity_array=intensity_array,\n        retention_time=retention_time,\n        annotation_dictionary=None,\n        binned_mz=None,\n        hashed_mz=None,\n    )\n\n    if full_sequence:\n        swt_object = swt_object.annotate_proforma(\n            proforma_str = full_sequence,\n            fragment_tol_mass = 0.01, # We consider two peaks (actual and theoretical) \"equivalent\" if they are within +/- 0.01 Da\n            fragment_tol_mode = 'Da',\n            ion_types = 'by',\n            max_ion_charge = max(1, precursor_charge - 1)\n        )\n    return swt_object",
      "cellType": "code"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 66,
    "isConflict": true,
    "testId": "conflict-row-17",
    "base": {
      "exists": true,
      "content": "# from spectrum_utils.proforma import Modification\n# Example with Scan 8090\n# mod_1 = Modification(  \n    # mass = 0.9848,\n    # position = 4,\n    # label = 'Deamidation'\n# )\n# modifications_list = [mod_1]\nscan_8090 = get_SWT_object(\n    mzml_path=full_calibrated_mzml_path,\n    scan_number = 8090,\n    full_sequence = 'AVVQ[Deamidated]DPALKPLALVYGEATSR',\n)\nplot_MS2(scan_8090, title='Scan 8090: Original Spectrum')",
      "cellType": "code"
    },
    "current": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "incoming": {
      "exists": true,
      "content": "# from spectrum_utils.proforma import Modification\n# Example with Scan 8090\n# mod_1 = Modification(  \n    # mass = 0.9848,\n    # position = 4,\n    # label = 'Deamidation'\n# )\n# modifications_list = [mod_1]\nscan_8090 = get_SWT_object(\n    mzml_path=full_calibrated_mzml_path,\n    scan_number = 8090,\n    full_sequence = 'AVVQ[Deamidated]DPALKPLALVYGEATSR',\n)\nplot_MS2(scan_8090, title='Scan 8090: Original Spectrum')",
      "cellType": "code"
    }
  },
  {
    "rowIndex": 67,
    "isConflict": true,
    "testId": "conflict-row-18",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "scan_8090 = get_SWT_object(\n    mzml_path=full_calibrated_mzml_path,\n    scan_number = 8090,\n    full_sequence = 'AVVQ[Deamidated]DPALKPLALVYGEATSR',\n)\n\nplot_MS2(scan_8090, title='Scan 8090: Original Spectrum')",
      "cellType": "code"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 68,
    "isConflict": false,
    "testId": "row-68",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "WIDTH_OF_BIN = 0.01\ndef to_idx(num):\n    return int(num // WIDTH_OF_BIN)\n\n# Bin the mz\nscan_8090.binned_mz = np.empty_like(scan_8090.mz, dtype=int)\nfor i in range(len(scan_8090.mz)):\n    scan_8090.binned_mz[i] = to_idx(scan_8090.mz[i])\n\n# Create a binned_spectrum SWT object for plotting purposes only\nbinned_spectrum = get_SWT_object(\n    mzml_path=full_calibrated_mzml_path,\n    scan_number = 8090,\n    full_sequence = 'AVVQ[Deamidated]DPALKPLALVYGEATSR',\n)\nfor i in range (len(binned_spectrum.mz)):\n    binned_spectrum.mz[i] = scan_8090.binned_mz[i] #Re-writing the mz_array with the binned mz values\n\n# Plot the binned spectrum\nplot_MS2(binned_spectrum, 'Scan 8090: Binned Spectrum')\n",
      "cellType": "code"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  },
  {
    "rowIndex": 69,
    "isConflict": true,
    "testId": "conflict-row-19",
    "base": {
      "exists": true,
      "content": "HASH_BUCKETS = 800  # Target dimensionality\ndef hasher(num: int) -> int:\n    \"\"\"\n    Hash function that maps sparse indices to a fixed number of buckets.\n    Input: Large sparse index (e.g., 12910)\n    Output: Small bucket index (0 to 399)\n    \"\"\"\n    # Convert integer to bytes for hashing (rapidhash expects byte input)\n    byte_representation = int(num).to_bytes(8, 'little')\n    # Hash and mod to get bucket index in range [0, hash_buckets-1]\n    return rapidhash(byte_representation) % HASH_BUCKETS\n# Set-up\nhashed_mz = []\nhashed_intensity = []\nhash_vector = [0] * HASH_BUCKETS\nmz_intensity_map = {}\nfor i, mz in enumerate(scan_8090.mz):\n    mz_intensity_map[to_idx(mz)] = scan_8090.intensity[i]\n# Hash the mz and add the intensities as we go\nfor sparse_idx, intensity in mz_intensity_map.items():\n    bucket_idx = hasher(sparse_idx)\n    hash_vector[bucket_idx] += intensity\n    hashed_mz.append(bucket_idx)\n    hashed_intensity.append(hash_vector[bucket_idx])\n# Update the hashed mz and intensities\nscan_8090.hashed_mz = hashed_mz\nscan_8090.hashed_intensity = hashed_intensity\n# Create a hashed_spectrum SWT object for plotting purposes only\nhashed_spectrum = get_SWT_object(\n    mzml_path=full_calibrated_mzml_path,\n    scan_number = 8090,\n    full_sequence = 'AVVQ[Deamidated]DPALKPLALVYGEATSR',\n)\nfor i in range (len(hashed_spectrum.mz)):\n    hashed_spectrum.mz[i] = scan_8090.hashed_mz[i] #Re-writing the mz_array with the hashed mz values\n    hashed_spectrum.intensity[i] = scan_8090.hashed_intensity[i] #Re-writing the intensity_array with the summed intensity values\n# Plot the hashed spectrum\nplot_MS2(hashed_spectrum, 'Scan 8090: Hashed Spectrum')\n",
      "cellType": "code"
    },
    "current": {
      "exists": true,
      "content": "HASH_BUCKETS = 800  # Target dimensionality\ndef hasher(num: int) -> int:\n    \"\"\"\n    Hash function that maps sparse indices to a fixed number of buckets.\n    Input: Large sparse index (e.g., 12910)\n    Output: Small bucket index (0 to 399)\n    \"\"\"\n    # Convert integer to bytes for hashing (rapidhash expects byte input)\n    byte_representation = int(num).to_bytes(8, 'little')\n    # Hash and mod to get bucket index in range [0, hash_buckets-1]\n    return rapidhash(byte_representation) % HASH_BUCKETS\n# Set-up\nhashed_mz = []\nhashed_intensity = []\nhash_vector = [0] * HASH_BUCKETS\nmz_intensity_map = {}\nfor i, mz in enumerate(scan_8090.mz):\n    mz_intensity_map[to_idx(mz)] = scan_8090.intensity[i]\n# Hash the mz and add the intensities as we go\nfor sparse_idx, intensity in mz_intensity_map.items():\n    bucket_idx = hasher(sparse_idx)\n    hash_vector[bucket_idx] += intensity\n    hashed_mz.append(bucket_idx)\n    hashed_intensity.append(hash_vector[bucket_idx])\n# Update the hashed mz and intensities\nscan_8090.hashed_mz = hashed_mz\nscan_8090.hashed_intensity = hashed_intensity\n# Create a hashed_spectrum SWT object for plotting purposes only\nhashed_spectrum = get_SWT_object(\n    mzml_path=full_calibrated_mzml_path,\n    scan_number = 8090,\n    full_sequence = 'AVVQ[Deamidated]DPALKPLALVYGEATSR',\n)\nfor i in range (len(hashed_spectrum.mz)):\n    hashed_spectrum.mz[i] = scan_8090.hashed_mz[i] #Re-writing the mz_array with the hashed mz values\n    hashed_spectrum.intensity[i] = scan_8090.hashed_intensity[i] #Re-writing the intensity_array with the summed intensity values\n# Plot the hashed spectrum\nplot_MS2(hashed_spectrum, 'Scan 8090: Hashed Spectrum')",
      "cellType": "code"
    },
    "incoming": {
      "exists": true,
      "content": "HASH_BUCKETS = 800  # Target dimensionality\ndef hasher(num: int) -> int:\n    \"\"\"\n    Hash function that maps sparse indices to a fixed number of buckets.\n    Input: Large sparse index (e.g., 12910)\n    Output: Small bucket index (0 to 399)\n    \"\"\"\n    # Convert integer to bytes for hashing (rapidhash expects byte input)\n    byte_representation = int(num).to_bytes(8, 'little')\n    # Hash and mod to get bucket index in range [0, hash_buckets-1]\n    return rapidhash(byte_representation) % HASH_BUCKETS\n# Set-up\nhashed_mz = []\nhashed_intensity = []\nhash_vector = [0] * HASH_BUCKETS\nmz_intensity_map = {}\nfor i, mz in enumerate(scan_8090.mz):\n    mz_intensity_map[to_idx(mz)] = scan_8090.intensity[i]\n# Hash the mz and add the intensities as we go\nfor sparse_idx, intensity in mz_intensity_map.items():\n    bucket_idx = hasher(sparse_idx)\n    hash_vector[bucket_idx] += intensity\n    hashed_mz.append(bucket_idx)\n    hashed_intensity.append(hash_vector[bucket_idx])\n# Update the hashed mz and intensities\nscan_8090.hashed_mz = hashed_mz\nscan_8090.hashed_intensity = hashed_intensity\n# Create a hashed_spectrum SWT object for plotting purposes only\nhashed_spectrum = get_SWT_object(\n    mzml_path=full_calibrated_mzml_path,\n    scan_number = 8090,\n    full_sequence = 'AVVQ[Deamidated]DPALKPLALVYGEATSR',\n)\nfor i in range (len(hashed_spectrum.mz)):\n    hashed_spectrum.mz[i] = scan_8090.hashed_mz[i] #Re-writing the mz_array with the hashed mz values\n    hashed_spectrum.intensity[i] = scan_8090.hashed_intensity[i] #Re-writing the intensity_array with the summed intensity values\n# Plot the hashed spectrum\nplot_MS2(hashed_spectrum, 'Scan 8090: Hashed Spectrum')\n",
      "cellType": "code"
    }
  },
  {
    "rowIndex": 70,
    "isConflict": false,
    "testId": "row-70",
    "base": {
      "exists": false,
      "content": null,
      "cellType": null
    },
    "current": {
      "exists": true,
      "content": "Side by side\n\n\n",
      "cellType": "markdown"
    },
    "incoming": {
      "exists": false,
      "content": null,
      "cellType": null
    }
  }
]

=== RESOLVING CONFLICTS ===

Resolving conflict row 0 (rowIndex 15)...
  -> Cells: base=true, current=true, incoming=true
  -> Clicking "Use Current" (odd index)
  -> Modified text with: (current taken - divisible by 5)
Resolving conflict row 1 (rowIndex 16)...
  -> Cells: base=false, current=false, incoming=true
  -> Clicking "Use Incoming" (even index)
Resolving conflict row 2 (rowIndex 19)...
  -> Cells: base=true, current=true, incoming=false
  -> Clicking "Use Current" (odd index)
Resolving conflict row 3 (rowIndex 20)...
  -> Cells: base=false, current=false, incoming=true
  -> Clicking "Use Incoming" (even index)
  -> Modified text with: (current taken - divisible by 5)
Resolving conflict row 4 (rowIndex 48)...
  -> Cells: base=true, current=false, incoming=true
  -> Clicking "Use Incoming" (even index)
Resolving conflict row 5 (rowIndex 49)...
  -> Cells: base=false, current=true, incoming=false
  -> Clicking "Use Current" (odd index)
Resolving conflict row 6 (rowIndex 50)...
  -> Cells: base=true, current=false, incoming=true
  -> Clicking "Use Incoming" (even index)
  -> Modified text with: (current taken - divisible by 5)
Resolving conflict row 7 (rowIndex 51)...
  -> Cells: base=false, current=true, incoming=false
  -> Clicking "Use Current" (odd index)
Resolving conflict row 8 (rowIndex 52)...
  -> Cells: base=true, current=false, incoming=true
  -> Clicking "Use Incoming" (even index)
Resolving conflict row 9 (rowIndex 53)...
  -> Cells: base=false, current=true, incoming=false
  -> Clicking "Use Current" (odd index)
Resolving conflict row 10 (rowIndex 55)...
  -> Cells: base=true, current=true, incoming=true
  -> Clicking "Use Current" (odd index)
  -> Modified text with: (current taken - divisible by 5)
Resolving conflict row 11 (rowIndex 57)...
  -> Cells: base=true, current=true, incoming=true
  -> Clicking "Use Current" (odd index)
Resolving conflict row 12 (rowIndex 58)...
  -> Cells: base=true, current=true, incoming=true
  -> Clicking "Use Incoming" (even index)
Resolving conflict row 13 (rowIndex 60)...
  -> Cells: base=true, current=true, incoming=true
  -> Clicking "Use Incoming" (even index)
  -> Modified text with: (current taken - divisible by 5)
Resolving conflict row 14 (rowIndex 61)...
  -> Cells: base=true, current=false, incoming=true
  -> Clicking "Use Incoming" (current doesn't exist)
  -> Modified text with: (current doesn't exist)
Resolving conflict row 15 (rowIndex 62)...
  -> Cells: base=false, current=true, incoming=false
  -> Clicking "Use Current" (incoming doesn't exist)
  -> Modified text with: (incoming doesn't exist)
Resolving conflict row 16 (rowIndex 63)...
  -> Cells: base=true, current=true, incoming=true
  -> Clicking "Use Current" (odd index)
Resolving conflict row 17 (rowIndex 66)...
  -> Cells: base=true, current=false, incoming=true
  -> Clicking "Use Incoming" (even index)
Resolving conflict row 18 (rowIndex 67)...
  -> Cells: base=false, current=true, incoming=false
  -> Clicking "Use Current" (odd index)
Resolving conflict row 19 (rowIndex 69)...
  -> Cells: base=true, current=true, incoming=true
  -> Clicking "Use Current" (odd index)

=== VERIFYING CHECKBOXES ===

Mark as resolved: true
Renumber execution counts: true

=== APPLYING RESOLUTION ===

Clicking "Apply Resolution"...
[MergeNB Web] Received message from session session-1770198739464-x20lujr2e: resolve
[Browser] [MergeNB] Received: {type: resolution-success, message: Conflicts resolved successfully!}
[MergeNB Web] Session closed: session-1770198739464-x20lujr2e
[MergeNB Web] WebSocket closed for session: session-1770198739464-x20lujr2e
[Browser] [MergeNB] WebSocket closed

=== VERIFYING RESOLVED NOTEBOOK ===

Resolved notebook has 71 cells

=== CELL-BY-CELL VERIFICATION ===

‚úì Conflict 0 (row 15): MATCH
  Reason: odd index -> current + divisible by 5
  Content preview: @title Run this to see the difference in collisions between ...
‚úì Conflict 1 (row 16): MATCH
  Reason: even index -> incoming
  Content preview: Why 'collision rate between spectrum pairs'? Above, we compa...
‚úì Conflict 2 (row 19): MATCH
  Reason: odd index -> current
  Content preview: Step 1: Spectrum Binning Now we implement the first step of ...
‚úì Conflict 3 (row 20): MATCH
  Reason: even index -> incoming + divisible by 5
  Content preview: Step 1: Spectrum Binning Now we implement the first step of ...
‚úì Conflict 4 (row 48): MATCH
  Reason: even index -> incoming
  Content preview: b_mz = [ 72.044114, 171.112528, 270.180942, 398.239520, 513....
‚úì Conflict 5 (row 49): MATCH
  Reason: odd index -> current
  Content preview: b_mz = [ 72.044114, 171.112528, 270.180942, 398.239520, 513....
‚úì Conflict 6 (row 50): MATCH
  Reason: even index -> incoming + divisible by 5
  Content preview: Now that we've visualized this theoretical ion ladder as a '...
‚úì Conflict 7 (row 51): MATCH
  Reason: odd index -> current
  Content preview: Now let's plot a real spectrum and use the theoretical ions ...
‚úì Conflict 8 (row 52): MATCH
  Reason: even index -> incoming
  Content preview: plot_MS2(get_MS2_object(full_calibrated_mzml_path, 9970, pep...
‚úì Conflict 9 (row 53): MATCH
  Reason: odd index -> current
  Content preview: plot_MS2(get_MS2_object(full_calibrated_mzml_path, 9970, pep...
‚úì Conflict 10 (row 55): MATCH
  Reason: odd index -> current + divisible by 5
  Content preview: seq = 'AVVQDPALKPLALVYGEATSR' spec_left = get_MS2_object(ful...
‚úì Conflict 11 (row 57): MATCH
  Reason: odd index -> current
  Content preview: seq = 'IITHPNFNGNTLDNDIMLIK' spec_left = get_MS2_object(full...
‚úì Conflict 12 (row 58): MATCH
  Reason: even index -> incoming
  Content preview: seq = 'RMVNNGHSFNVEYDDSQDK' spec_left = get_MS2_object(full_...
‚úì Conflict 13 (row 60): MATCH
  Reason: even index -> incoming + divisible by 5
  Content preview: seq = 'AVVQDPALKPLALVYGEATSR' spec_left = get_MS2_object(ful...
‚úì Conflict 14 (row 61): MATCH
  Reason: odd index -> incoming (current missing)
  Content preview: Let's do that once more, but this time annotating the spectr...
‚úì Conflict 15 (row 62): MATCH
  Reason: even index -> current (incoming missing)
  Content preview: Now we'll annotate the spectrum of the modified RMVNNGHSFNVE...
‚úì Conflict 16 (row 63): MATCH
  Reason: odd index -> current
  Content preview: seq_1= 'RMVNNGHSFNVEYDDSQDK' seq_2 = 'AVVQDPALKPLALVYGEATSR'...
‚úì Conflict 17 (row 66): MATCH
  Reason: even index -> incoming
  Content preview: from spectrum_utils.proforma import Modification Example wit...
‚úì Conflict 18 (row 67): MATCH
  Reason: odd index -> current
  Content preview: scan_8090 = get_SWT_object( mzml_path=full_calibrated_mzml_p...
‚úì Conflict 19 (row 69): MATCH
  Reason: odd index -> current
  Content preview: HASH_BUCKETS = 800 # Target dimensionality def hasher(num: i...

=== VERIFICATION SUMMARY ===

Total conflicts verified: 20
Matching: 20
Discrepancies: 0

=== TEST PASSED ===

[90m[main 2026-02-04T09:52:42.824Z][0m Extension host with pid 170837 exited with code: 0, signal: unknown.
Exit code:   0
